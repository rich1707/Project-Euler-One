---
title: "Problems from Project Euler"
subtitle: "Solving the first ten problems on Project Euler using Base R"
author: "Richard Ryan"
date: "1 October 2024"
format: html
editor: visual
theme: 
   - cyborg
   - custom.scss
execute: 
  message: false
  warning: false
toc: TRUE
toc-depth: 1
---

# Introduction

The following are solutions to some of the simpler and more accessible problems from the [Project Euler website](http://projecteuler.net/).

Using `R` to solve these problems is a particularly interesting exercise, as it involves packages outside the data science mainstream, and requires techniques not often used when analysing data. For example, a `while()` loop is almost never needed in data science, but in solving mathematical problems it is, as we shall see, commonplace.

We shall at all times attempt to solve these problems in the most computationally efficient way, though no doubt many of our solutions will fall some way short of the ideal.

As always, we start by loading the packages we shall need:

```{r}
library(numbers)
```

# Problem 1: Multiples of 3 or 5

**The Problem:**

*If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.*

*Find the sum of all the multiples of 3 or 5 below 1000.*

**The Solution:**

This is the [first problem](http://projecteuler.net/problem=1) on the Project Euler Website.

It isn't a difficult problem to solve in any programming language, but the vectorised nature of `R` makes the solution particularly concise.

First we create of a vector of integers from 1 to 999. We then filter for numbers divisible by either 3 or 5 and pass the new vector to the `sum()` function.

```{r}
numbers <- 1:999

numbers[numbers %% 3 == 0 | numbers %% 5 == 0] |>
   sum()
```

# Problem 2: Even Fibonacci numbers

**The Problem:**

*Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:*

```         
     1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
```

*By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.*

**The solution:**

This is the [second problem](http://projecteuler.net/problem=2) on the Project Euler website.

Here we need a `while()` loop to limit the last term of the fibonacci sequence to 4 million or less. We start the index at 1 and generate the sequence, testing the last term to see whether it exceeds 4 million. If it is less than 4 million, then we increase the index by 1 and repeat the process.

When the last time in the sequence is greater than 4 million, we simply filter the vector to exclude any superfluous terms, filter it again to obtain the even numbers, and finally pass this new vector to the `sum()` function.

It's not difficult to write our own function to calculate the Fibonacci sequence, but we can save a bit of time by calling on the `fibonacci()` function from the `{numbers}` package.

```{r}
index <- 1
fib_last_term <- 0

while (fib_last_term <= 4e6) {
   fib_sequence <- fibonacci(index, sequence = TRUE) 
   fib_last_term <- fib_sequence[index]
   index <- index + 1
}

fib_sequence <- fib_sequence[fib_sequence <= 4e6]

fib_sequence[fib_sequence %% 2 == 0] |>
   sum()
```

# Problem 3: Largest prime factor

**The problem:**

*The prime factors of 13195 are 5, 7, 13 and 29.*

*What is the largest prime factor of the number 600,851,475,143?*

**The solution:**

This is the [third problem](http://projecteuler.net/problem=3) of Project Euler.

We have the option here of writing a function to implement the Sieve of Eratosthenes. However, it is much simpler to use the `primeFactors()` function from the `{numbers}` package, which, together with the pipe `|>` function, enables us to solve this problem in a very few lines of code:

```{r}
max_prime_factor <- 
   gsub(",", "", "600,851,475,143") |>
   as.numeric() |>
   primeFactors() |> 
   max() 

max_prime_factor
```

# Problem 4: Largest palindrome product

**The problem**

*A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.*

*Find the largest palindrome made from the product of two 3-digit numbers.*

**The solution:**

This is the [fourth problem](http://projecteuler.net/problem=4) of Project Euler.

This is another fairly simple problem. We start by creating two vectors of all possible three digit numbers. We use the `outer()` function to calculate the outer-product before converting to a vector and arranging in decreasing order. Our task is then to find the first palindrome in the vector we have just calculated.

We do this with a `for()` loop. Each number is converted to a string and stored as a character variable `word`. We then create a second character variable, `word_reversed`, which is made by reversing the characters of the string stored in `word`. When `word == word_reversed` we have found our answer.

```{r}
num_vec_one <- 100:999
num_vec_two <- 100:999

number_vector <- outer(num_vec_one, num_vec_two) |>
   as.vector() |>
   sort(decreasing = TRUE)

for (i in number_vector) {
   word <- as.character(i)
   word_reversed <- strsplit(word, "") |>
      unlist() |>
      rev() |>
      paste(collapse = "")
   if (word == word_reversed) break
}

as.numeric(word)
```

# Problem 5: Smallest multiple

**The problem:**

*2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.*

*What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?*

**The solution:**

This is the [fifth problem](http://projecteuler.net/problem=5) of Project Euler.

It is obvious that the solution is some multiple of 2520. Therefore we need a `while()` loop that starts at 2520 and increases by 2520 on each iteration. We test whether all numbers from 1 to 20 divide evenly into the number in question; when we find a number for which this holds we have our solution.

```{r}
candidate <- 2520
remainder <- 1

while (remainder != 0) {
   rem_vec <- candidate %% 1:20
   remainder <- sum(rem_vec)
   candidate <- candidate + 2520
}
solution <- candidate - 2520; solution
```

# Problem 6: Sum square difference

**The problem:**

*The sum of the squares of the first ten natural numbers is,* $$1^2 + 2^2 + \ldots + 10^2 = 385$$

*The square of the sum of the first ten natural numbers is,* $$(1 + 2 + \ldots + 10)^2 = 552 = 3025$$

*Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is* $3025−385=2640.$

*Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.*

**The solution:**

This is the [sixth problem](http://projecteuler.net/problem=6) of Project Euler.

This is another very simple problem given that the functions we need are vectorised. First we sum all the numbers from 1 to 100 and square the result. Second we square the numbers from 1 to 100 and we sum the result. We then take the second number from the first.

```{r}
first_number <- sum(1:100)**2
second_number <- (1:100)**2 |> sum()
first_number - second_number
```

# Problem 7: the 10001st prime

**The problem:**

*By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.*

*What is the 10,001st prime number?*

**The solution**

This is the [seventh problem](http://projecteuler.net/problem=7) of Project Euler.

The following is certainly the simplest way to solve this problem. We use a `while()` loop to iterate through the integers, testing each one with the `isPrime()` function from the `{numbers}` package. If the number is prime, then we add 1 to the prime count. We break when the total number of primes reaches 10,001. The mechanics of the `while()` loop mean that the `index_number` count will have been advanced automatically; therefore deducting 1 will give us the correct answer.

```{r}
index_number <- 1  
prime_count <- 1 

while (prime_count <= 10001) {
   if (isPrime(index_number)) {
      prime_count <- prime_count + 1
      index_number <- index_number + 1
   } else {
      index_number <- index_number + 1
   } 
}

index_number - 1
```

# Problem 8: Largest product in a series

**The problem:**

*The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.*

"73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450"

*Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?*

**The solution**

This is the [eighth problem](http://projecteuler.net/problem=8) of Project Euler.

First we read in the above number as a string. We then iterate over it, using `substr()` to obtain every possible 13 digit sequence. For each sequence, we split it into its separate digits, convert it to a numeric and calculate the product. We test this product against the previously highest product and replace one for the other when required.

```{r}
digits_1k <- "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846106495514929086256932197846862248283972241375657056057490261407972968652414535100474821663704844031998900089524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
```

```{r}
step_size <- 12
highest_product <- 0

for (i in 1: nchar(digits_1k)) {
   start_point <- i
   prod_string <- substr(digits_1k, start_point, start_point + step_size)
   prod_numeric <- strsplit(prod_string, "") |>
      unlist() |>
      as.numeric() |>
      prod()
   if (prod_numeric > highest_product) {
      highest_product <- prod_numeric
   }
}

highest_product
```

# Problem 9: Special Pythagorean triplet

**The problem:**

*A Pythagorean triplet is a set of three natural numbers, a \< b \< c, for which,* $$a^2 + b^2 = c^2$$

*For example,* $32 + 42 = 9 + 16 = 25 = 52$.

*There exists exactly one Pythagorean triplet for which* $a + b + c = 1000$.

*Find the product* $abc$.

**The Solution:**

This is the [nineth problem](http://projecteuler.net/problem=9) of Project Euler.

We start by constructing two vectors `poss_a` and `poss_b`. As we are told that $$ a < b < c$$ we know that $a$ must be less than or equal to `floor(1000 / 3)` and $b$ must be less than or equal to `floor(1000 /2)`. Obviously $$c = 1000 - a - b$$

We then use a nested `for()` loop to iterate through each of the `poss_a` and `poss_b` sequences. On each iteration we test whether $a$, $b$ and $c$ are a Pythagorean triple. Once we have found a solution we can `break` and exit the loop.

```{r}
poss_a <- 1: floor(1000 / 3)
poss_b <- 1: floor(1000 / 2)
a <- 0
b <- 0
c <- 0
found_solution <- FALSE

for (i in seq_along(poss_a)) {
   for (j in seq_along(poss_b)) {
      k <- 1000 - i - j
      if (i**2 + j**2 == k**2) {
         a <- i
         b <- j
         c <- k
         found_solution <- TRUE
         break
      }
   }
   if (found_solution == TRUE) {
      break
   }
}

prod(a, b, c)
```

# Problem 10: Summation of primes

**The problem:**

*The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.*

*Find the sum of all the primes below two million.*

**The solution**

This is the [tenth problem](http://projecteuler.net/problem=10) of Project Euler.

This is quite an easy problem. We use the `atkin_sieve()` function from the `{numbers}` package to build a vector of primes less than two million. Then we `sum()` the resultant vector.

```{r}
atkin_sieve(2e6) |>
   sum()
```

The first ten problems are now complete. All of the questions above are fairly simple, but it was nonetheless a worthwhile exercise as it provided experience in using `R` as a programming language outside the norm of data science.
